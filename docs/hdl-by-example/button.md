# 按钮开关

## 需求

让我们来实现一个控制台灯的按钮开关：按下开关的时候，灯会亮起来；再次按下开关的时候，灯就熄灭了。

根据上面的需求，可以设计如下的输入输出信号：

输入：

1. `button`：1 表示按钮被按下，0 表示按钮处于弹起的状态

输出：

1. `light`：1 表示灯亮起，0 表示灯熄灭

## 波形

分析上面的需求，可以发现，此时不再满足我们刚刚学到的 **组合逻辑** 的特点，虽然输出（`light`）也是随着输入信号变化而变化，但是第一次按的时候输出 `1`，第二次按的时候输出了 `0`，说明输出不仅随着输入变化而变化。

仔细一想，我们可以发现一个规律：按钮被按下的时候，灯会从亮起到熄灭，或者从熄灭到亮起，说明输出的值是之前输出的值取反。而按钮按下（从 `0` 变成 `1`）是用来触发取反的动作。

根据分析，可以得到下面的波形：

<script type="WaveDrom">
{
  signal:
    [
      { name: "button", wave: "0.1.0.1.0..1"},
      { name: "light", wave: "0.1...0....1"}
    ]
}
</script>

## 电路

经过分析，可以发现 `light` 输出与它本身的历史状态有关，并且正好是取反的关系。如果我们依然采用组合逻辑来实现，就会写出形如 `light <= ~light;` 的代码，对应的电路就出现了环路，此时 `light` 会不断在 `0` 和 `1` 之间震荡，不能实现我们想要的效果。

对于这一类 **输出与历史状态相关**，并且 **输出在某个信号的上升沿变化** 的信号，我们通常使用 **时序逻辑** 来实现。那么时序逻辑对应什么样的电路呢？回顾一下，只有触发器的真值表中出现了上升沿：

| 输入 D | 输入 C     | 输出 Q |
| ---- | -------- | ---- |
| X    | 0        | 维持不变 |
| X    | 1        | 维持不变 |
| 0    | 0->1 上升沿 | 0    |
| 1    | 0->1 上升沿 | 1    |

这时候，我们把 `button` 连接到触发器的 `C` 端口，就实现了上升沿触发的目的；为了实现每次触发，让输出的结果取反，可以把触发器的 `Q` 经过一个非门（NOT）再连接到触发器的 `D` 端口：

![](imgs/toggle.png)

上图的 `DFF_P` 就是 D 触发器的意思。

!!! question "这个电路图不也成了一个环吗，为什么不会出现循环振荡？"

    这就是引入触发器的作用。用通俗的方式理解，可以认为组合电路是持续在变化，才会出现 A 变化导致 B 变化，B 变化导致 A 变化，一直循环；而触发器使得只有在时钟上升沿的时候，触发器的输入 D 会引发输出 Q 的变化，而当时钟上升沿结束以后，输出 Q 也许会导致输入 D 变化（比如上面的例子），但此时时钟已经稳定了，此时输出 Q 是稳定不变的，因此不会出现循环振荡的问题。

## 代码

最后再用 HDL 来实现如上的功能。之前我们已经学过，组合电路比较简单，直接把计算结果 **连接** 到输出即可。但时序逻辑里，我们需要显式的声明一个寄存器（对应电路里的触发器），并且 **严格** 按照下面的方式，把信号 **连接** 到触发器的输入 D 端口。

### VHDL

首先，还是根据前面确定的输出信号编写 `entity`：

```vhdl
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity button is
    Port ( button : in  STD_LOGIC;
           light  : in  STD_LOGIC);
end button;
```